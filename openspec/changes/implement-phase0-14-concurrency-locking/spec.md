# Phase 0.14: Concurrency & Locking Specification

## Overview
This phase introduces strict optimistic concurrency control to the Core Runtime and an optional LockManager module. The goal is to prevent double-writes and manage coordination between agents without compromising the purity, determinism, or event-driven nature of the Core.

## 1. Core: Anti-Double Write (Optimistic Concurrency)

### Principle
Event-sourced optimistic concurrency based on entity versioning.
- **No blocking locks** in the Core.
- **No waits**.
- **Deterministic** behavior (replay produces same conflict).
- **Version Authority**: The version of an entity is derived exclusively from the EventStore and is immutable outside of event replay.

### Specifications

#### Command Contract
Commands operating on an aggregate/entity MUST optionally accept:
- `expected_version`: The version of the entity the agent believes it is modifying. If `expected_version` is omitted, the command is processed without concurrency guarantees.

#### Runtime Behavior
When processing a command with `expected_version`:
1.  Runtime loads the current state (and version) of the target entity.
2.  **Check**: If `expected_version != current_version`:
    - **Refuse** the command.
    - **Publish** `evt.<entity>.conflict`.
    - **Do NOT** apply the command or generate other side effects.

#### Conflict Event
Subject: `evt.<entity>.conflict`
Payload:
```json
{
  "entity_id": "string",
  "expected_version": 10,
  "current_version": 11,
  "reason": "Optimistic locking failure: version mismatch"
}
```

#### Invariants
- **Determinism**: Replaying the same command stream against the same history MUST produce the same conflict event.
- **Idempotency**: If the command is re-sent (same `idempotency_key`), the result (conflict) is returned/re-published exactly as it was the first time.
- **Storage**: The conflict event IS persisted in the EventStore to ensure deterministic replay.

## 2. Runtime Module: LockManager (Optional)

### Role
A cooperative, lease-based locking mechanism for long-running tasks or coordination.
- **Opt-in**: Not required for basic operation.
- **Event-Sourced**: Lock state is derived from events.

### API (Commands)
- `cmd.lock.acquire`
    - Payload: `{ resource_id, owner_id, ttl_seconds }`
- `cmd.lock.release`
    - Payload: `{ resource_id, owner_id }`
- `cmd.lock.refresh` (Optional)

### Events
- `evt.lock.acquired`: `{ resource_id, owner_id, expires_at }`
- `evt.lock.denied`: `{ resource_id, requested_by, current_owner, reason }`
- `evt.lock.released`: `{ resource_id, owner_id }`
- `evt.lock.expired`: `{ resource_id }` (Generated by system/timer or lazily checked)

### Properties
- **Soft Locks**: These are advisory/cooperative. The Core does not enforce them on other operations.
- **TTL**: Mandatory to prevent deadlocks if an agent crashes. TTL and expiration are evaluated by the Runtime, not by agents, to ensure consistency across distributed deployments.
- **Non-blocking**: `acquire` returns immediately with `acquired` or `denied`.

## 3. Implementation Plan

### MeshForge Runtime
1.  **Core**:
    - Update `RuntimeEngine` to handle `expected_version` logic.
    - Define `ConflictEvent` schema.
2.  **LockManager**:
    - Implement `LockManagerAdapter` (System Agent).
    - Handle `cmd.lock.*` -> `evt.lock.*`.
    - Implement TTL logic (likely lazy check on acquire, or separate ticker).

### MeshForge Factory
- Add `component_toggles.lock_manager`.
- Wire `LockManagerAdapter` if enabled.

### Validation
- **Unit Tests**:
    - Concurrent commands on same entity -> one succeeds, one conflicts.
    - Lock acquire/release/deny scenarios.
- **Integration**:
    - JetStream smoke test with concurrent agents.
